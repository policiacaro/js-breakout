<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Gamedev Canvas Workshop</title>
  <style>
    * { padding: 0; margin: 0; }
    canvas { background: #eee; display: block; margin: 0 auto; }
  </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="720"></canvas>

<script>
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let x = canvas.width/2;
  let y = canvas.height - 40 - 10; // minus 40 is paddle height, minus 10 is ball radius
  let dx = 2; // ball speed and direction for x axis
  let dy = -2; // ball speed and direction y axis
  let ballRadius = 10; // ball size
  let paddleY = canvas.height - 40; // paddle starting corner for draw function
  let paddleHeight = 10; // size of paddle on y axis
  let paddleWidth = 45;// size of paddle on x axis
  let paddleX = (canvas.width-paddleWidth) / 2; // paddle starting corner for draw function
  const colors = ["#0095DD", "#0006DD", "#7100DD", "#00DD6B"]; // array of colors for the ball to change into when it bounces
  let colorVariable = 0;

  //variables for bricks; all dimensions and starting points
  let brickRowCount = 5;
  let brickColumnCount = 6;
  let brickWidth = 60;
  let brickHeight = 20;
  let brickPadding = 5;
  let brickOffsetTop = 30;
  let brickOffsetLeft = 50;
  let bricks = [];
  for(let c=0; c<brickColumnCount; c++) {
    bricks[c] = [];
    for(let r=0; r<brickRowCount; r++) {
      bricks [c][r] = { x: 0, y: 0, status: 1 };
    }
  }
  let rightPressed = false;
  let leftPressed = false;


  function colorChanger() { // cycles through the colors in colors array
    colorVariable += 1;
    if (colorVariable > 3) colorVariable = 0;
  }

  function drawBall() { // creates the ball on screen
    ctx.beginPath();
    ctx.arc(x, y, ballRadius, 0, Math.PI*2);
    ctx.fillStyle = colors[colorVariable];
    ctx.fill();
    ctx.closePath();
  }

  function drawPaddle() { // creates the paddle on screen
    ctx.beginPath();
    ctx.rect(paddleX, paddleY, paddleWidth, paddleHeight);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
  }

  function keyDownHandler(e) { // check if right arrow is pressed
    if(e.key == "Right" || e.key == "ArrowRight") {
      rightPressed = true;
    } else if(e.key == "Left" || e.key == "ArrowLeft") {
      leftPressed = true;
    }
  }

  function keyUpHandler(e) { // check if left arrow is pressed
    if(e.key == "Right" || e.key == "ArrowRight") {
      rightPressed = false;
    } else if(e.key == "Left" || e.key == "ArrowLeft") {
      leftPressed = false;
    }
  }

  function collisionDetection() {
    for(let c=0; c<brickColumnCount; c++) {
      for(let r=0; r<brickRowCount; r++) {
        let b = bricks[c][r];
        if (x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight) {
          dy = -dy;
          b.status = 0;
        }
      }
    }
  }

  function drawBricks() {
    for(let c=0; c<brickColumnCount; c++) {
      for(let r=0; r<brickRowCount; r++) {
        if (bricks[c][r].status === 1) {
          let brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
          let brickY = (r * 23)+brickOffsetTop;
          bricks[c][r].x = brickX;
          bricks[c][r].y = brickY;
          ctx.beginPath();
          ctx.rect(brickX, brickY, brickWidth, brickHeight);
          ctx.fillStyle = "#0095DD";
          ctx.fill();
          ctx.closePath();
        }
      }
    }
  }

  function draw() { // main gameplay loop, drawing canvas, paddle and ball
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawBall();
    drawPaddle();
    collisionDetection();

    if (leftPressed) {
      paddleX -= 4;
      if (paddleX < 0) {
        paddleX = 0;
      }
    } else if (rightPressed) {
      paddleX += 4;
      if (paddleX + paddleWidth > canvas.width) {
        paddleX = canvas.width - paddleWidth;
      }
    }
    x += dx;
    y += dy;
    //this is when the ball hits the top of the screen, reverse direction
    if (y <= canvas.height - (canvas.height - ballRadius)) {
      dy = -dy;
      colorChanger();
    }
    //when the ball hits the paddle, reverse ball direction and add to ball speed
    if ((y >= (paddleY - ballRadius) && y <= (paddleY + paddleHeight)) && (x >= paddleX && x <= paddleX + paddleWidth)) {
      dx += 0.2;
      dy += 0.2;
      dy = -dy;
      colorChanger();
    }

    //when ball hits bottom of screen, GAME OVER alert message
    if (y >= canvas.height - ballRadius) {
      alert(`GAME OVER`);
      document.location.reload();
      clearInterval(interval); //Needed for Chrome to end game
    }

    //when ball hits left side of screen, reverse direction
    if (x <= 10) {
      dx = -dx;
      colorChanger();
    }
    //when ball hits right side of screen, reverse direction
    if (x >= 470) {
      dx = -dx;
      colorChanger();
    }
  }

  document.addEventListener("keydown", keyDownHandler, false);
  document.addEventListener("keyup", keyUpHandler, false);

  let interval = setInterval(draw, 10); // needed to call variable in clearInterval function for Chrome

</script>

</body>
</html>
