<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Gamedev Canvas Workshop</title>
  <style>
    * { padding: 0; margin: 0; }
    canvas { background: #eee; display: block; margin: 0 auto; }
  </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="720"></canvas>

<script>
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let x = canvas.width/2;
  let y = canvas.height - 40 - 10; // minus 40 is paddle height, minus 10 is ball radius
  let dx = 2; // ball speed and direction for x axis
  let dy = -2; // ball speed and direction y axis
  let ballRadius = 10; // ball size
  let paddleY = canvas.height - 40; // paddle starting corner for draw function
  let paddleHeight = 10; // size of paddle on y axis
  let paddleWidth = 45;// size of paddle on x axis
  let paddleX = (canvas.width-paddleWidth) / 2; // paddle starting corner for draw function
  const colors = ["#0095DD", "#0006DD", "#7100DD", "#00DD6B"]; // array of colors for the ball to change into when it bounces
  let colorVariable = 0;
  let score = 0;
  let lives = 3;
  let gameStartFlag = false;

  //variables for bricks; all dimensions and starting points
  let brickRowCount = 1;
  let brickColumnCount = 6;
  let brickWidth = 60;
  let brickHeight = 20;
  let brickPadding = 5;
  let brickOffsetTop = 30;
  let brickOffsetLeft = 50;
  let bricks = [];
  for(let c=0; c<brickColumnCount; c++) {
    bricks[c] = [];
    for(let r=0; r<brickRowCount; r++) {
      bricks [c][r] = { x: 0, y: 0, status: 1 };
    }
  }
  let rightPressed = false;
  let leftPressed = false;
  let spacePressed = false;


  function colorChanger() { // cycles through the colors in colors array
    colorVariable += 1;
    if (colorVariable > 3) colorVariable = 0;
  }

  function drawBall() { // creates the ball on screen
    ctx.beginPath();
    ctx.arc(x, y, ballRadius, 0, Math.PI*2);
    ctx.fillStyle = colors[colorVariable];
    ctx.fill();
    ctx.closePath();
  }

  function drawPaddle() { // creates the paddle on screen
    ctx.beginPath();
    ctx.rect(paddleX, paddleY, paddleWidth, paddleHeight);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
  }

  function keyDownHandler(e) { // check if right/left arrow is pressed
    if (e.key == "Right" || e.key == "ArrowRight") {
      rightPressed = true;
    } else if (e.key == "Left" || e.key == "ArrowLeft") {
      leftPressed = true;
    }
    if (e.keyCode == 32 ) {
      spacePressed = true;
      gameStartFlag = true;
    }
  }

  function keyUpHandler(e) { // check if left arrow is pressed
    if (e.key == "Right" || e.key == "ArrowRight") {
      rightPressed = false;
    } else if (e.key == "Left" || e.key == "ArrowLeft") {
      leftPressed = false;
    }
    if (e.keyCode == 32) {
      spacePressed = false;
    }
  }

  function mouseMoveHandler(e) {
    let relativeX = e.clientX - canvas.offsetLeft;
    if (relativeX > 0 && relativeX < canvas.width) {
      paddleX = relativeX - paddleWidth/2;
    }
  }

  function collisionDetection() {
    for(let c=0; c<brickColumnCount; c++) {
      for(let r=0; r<brickRowCount; r++) {
        let b = bricks[c][r];
        if (b.status === 1 ) {
          if (x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight) {
            dy = -dy;
            b.status = 0;
            score += 100;
            if (score/100 === brickColumnCount * brickRowCount) {
              alert(`YOU WIN, CONGRATULATIONS! \n\nYour score was ${score} points, thank you for playing!`);
              document.location.reload();
            }
          }
        }
      }
    }
  }

  function drawScore() {
    ctx.font = "16px Arial";
    ctx. fillStyle = "Maroon";
    ctx.fillText("Score: "+score, 8, 20);
  }

  function drawLives() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "Maroon";
    ctx.fillText("Lives: "+lives, canvas.width-65, 20);
  }

  function drawBricks() {
    for(let c=0; c<brickColumnCount; c++) {
      for(let r=0; r<brickRowCount; r++) {
        if (bricks[c][r].status === 1) {
          let brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
          let brickY = (r * 23)+brickOffsetTop;
          bricks[c][r].x = brickX;
          bricks[c][r].y = brickY;
          ctx.beginPath();
          ctx.rect(brickX, brickY, brickWidth, brickHeight);
          ctx.fillStyle = "#0095DD";
          ctx.fill();
          ctx.closePath();
        }
      }
    }
  }

  function gameStart() {

  }

  function draw() { // main gameplay loop, drawing canvas, paddle and ball
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawBall();
    drawPaddle();
    drawScore();
    drawLives();
    collisionDetection();

    if (leftPressed) {
      paddleX -= 4;
      if (paddleX < 0) {
        paddleX = 0;
      }
    } else if (rightPressed) {
      paddleX += 4;
      if (paddleX + paddleWidth > canvas.width) {
        paddleX = canvas.width - paddleWidth;
      }
    }
    if (gameStartFlag) {
      y += dy;
    }
    if (!gameStartFlag) {
      x = (paddleX + (paddleWidth/2));
    }
    //x += dx;
    //y += dy;
    //this is when the ball hits the top of the screen, reverse direction
    if (y <= canvas.height - (canvas.height - ballRadius)) {
      dy = -dy;
      colorChanger();
    }
    //when the ball hits the paddle, reverse ball direction and add to ball speed
    if ((y >= (paddleY - ballRadius) && y <= (paddleY + paddleHeight)) && (x >= paddleX && x <= paddleX + paddleWidth)) {
      if (gameStartFlag) {
        dx += 0.4;
        dy += 0.4;
        dy = -dy;
        colorChanger();
      }
    }

    //when ball hits bottom of screen, GAME OVER alert message
    if (y >= canvas.height - ballRadius) {
      lives--;
      gameStartFlag = false;
      if (!lives) {
        alert(`GAME OVER`);
        document.location.reload();
        //clearInterval(interval); //Needed for Chrome to end game
      } else{
        x = canvas.width/2;
        y = canvas.height - 40 - 10;
        dx = 2;
        dy = -2;
        paddleX = (canvas.width-paddleWidth)/2;
      }
    }

    //when ball hits left side of screen, reverse direction
    if (x <= 10) {
      dx = -dx;
      colorChanger();
    }
    //when ball hits right side of screen, reverse direction
    if (x >= 470) {
      dx = -dx;
      colorChanger();
    }
    requestAnimationFrame(draw);
  }

  document.addEventListener("keydown", keyDownHandler, false);
  document.addEventListener("keyup", keyUpHandler, false);
  document.addEventListener("mousemove", mouseMoveHandler, false);

  //let interval = setInterval(draw, 10); // needed to call variable in clearInterval function for Chrome
  draw();

</script>

</body>
</html>
